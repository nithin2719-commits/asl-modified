<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SignFlow - ASL Video Call</title>
    <link rel="stylesheet" href="/static/css/style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
</head>
<body>
    <div class="call-container">
        <!-- Enhanced Header with SignFlow Branding -->
        <div class="call-header">
            <div class="brand-info">
                <div class="brand-logo">
                    <i class="fas fa-sign-language"></i>
                </div>
                <div class="call-info">
                    <div class="brand-name-text">SignFlow</div>
                    <h2>ASL Video Call</h2>
                    <div class="call-status" id="call-status">
                        <span class="status-dot" id="call-status-dot"></span>
                        <span id="call-status-text">Waiting for peer...</span>
                    </div>
                </div>
            </div>
            <div class="call-meta">
                <div class="mini-pill live">
                    <span class="pulse-dot"></span>
                    <i class="fas fa-hand-sparkles"></i>
                    <span>ASL engine</span>
                </div>
                <div class="mini-bars" aria-label="Signal quality">
                    <span></span><span></span><span></span><span></span><span></span>
                </div>
                <div class="call-timer-pill">
                    <i class="fas fa-clock"></i>
                    <span id="call-timer">00:00:00</span>
                </div>
            </div>
        </div>

        <!-- Main Video Area -->
        <div class="video-area">
            <div class="video-main">
                <div class="left-control-dock">
                    <div class="floating-controls">
                        <button class="control-pill" id="logout-btn" title="Logout">
                            <i class="fas fa-right-from-bracket"></i>
                            <span class="btn-label">Logout</span>
                        </button>
                        <button class="control-pill" id="mute-btn" title="Toggle Microphone">
                            <i class="fas fa-microphone"></i>
                            <span class="btn-label">Mute</span>
                        </button>
                        <button class="control-pill" id="video-btn" title="Toggle Camera">
                            <i class="fas fa-video"></i>
                            <span class="btn-label">Video</span>
                        </button>
                        <button class="control-pill" id="asl-toggle-btn" title="Toggle ASL Interpreter">
                            <i class="fas fa-hands"></i>
                            <span class="btn-label">Start ASL</span>
                        </button>
                        <button class="control-pill end-pill" id="end-call-btn" title="End Call">
                            <i class="fas fa-phone-slash"></i>
                            <span class="btn-label">End</span>
                        </button>
                    </div>
                </div>

            <div class="call-stage">
                <!-- Meet-like framed Video Canvas -->
                <div class="remote-video-container call-panel">
                    <!-- Interpreter badge hidden per request -->
                    <video id="remote-peer" autoplay playsinline></video>
                        <!-- Local PIP -->
                        <div class="local-video-bubble">
                            <video id="local-video" autoplay muted playsinline></video>
                            <div class="participant-name">You</div>
                        </div>
                        <div class="gesture-telemetry">
                            <div class="telemetry-title">
                                <span class="dot"></span> ASL stream
                            </div>
                            <div class="telemetry-bars">
                                <span></span><span></span><span></span><span></span><span></span>
                            </div>
                            <div class="telemetry-meta">
                                <i class="fas fa-brain"></i>
                                <span id="live-letter">Listening...</span>
                            </div>
                        </div>
                    </div>

                    <div class="participant-info">
                        <div class="participant-name">ASL Interpreter</div>
                        <div class="asl-output" id="asl-output">Ready for ASL detection...</div>
                        <div class="asl-sentence" id="asl-sentence">Sentence: </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ASL Detection Canvas (Hidden) -->
        <canvas id="canvas" width="320" height="240" style="display:none;"></canvas>

        <!-- Camera Permission Prompt -->
        <div id="camera-prompt" class="camera-prompt">
            <div class="prompt-content">
                <div class="prompt-aura"></div>
                <div class="prompt-topline">
                    <span class="pill trust"><i class="fas fa-lock"></i> Local-only</span>
                    <span class="pill inline"><i class="fas fa-shield-alt"></i> Secure session</span>
                </div>
                <div class="prompt-hero">
                    <div class="prompt-icon">
                        <span class="icon-ring"></span>
                        <i class="fas fa-video"></i>
                    </div>
                    <div>
                        <p class="prompt-eyebrow">Permission handshake</p>
                        <h3>Camera Access Required</h3>
                        <p class="prompt-lede">SignFlow runs ASL detection on your device. Grant access so we can see your hands.</p>
                    </div>
                </div>

                <div class="permission-steps">
                    <div class="step">
                        <span class="step-number">1</span>
                        <div>
                            <p class="step-title">Click "Allow" in your browser</p>
                            <p class="step-copy">The prompt sits beside the address bar.</p>
                        </div>
                    </div>
                    <div class="step">
                        <span class="step-number">2</span>
                        <div>
                            <p class="step-title">Stay in frame</p>
                            <p class="step-copy">Keep your upper body centered for crisp tracking.</p>
                        </div>
                    </div>
                    <div class="step">
                        <span class="step-number">3</span>
                        <div>
                            <p class="step-title">Keep it private</p>
                            <p class="step-copy">Video stays local unless you're live in the call.</p>
                        </div>
                    </div>
                </div>

                <div class="prompt-actions">
                    <button id="start-camera-btn" class="btn-primary allow-btn">
                        <span class="btn-glow"></span>
                        Allow Camera &amp; Start
                    </button>
                    <button type="button" class="help-toggle" id="permissions-help">
                        Need help unblocking?
                    </button>
                </div>

                <div class="help-panel" id="help-panel" hidden>
                    <div class="help-item"><i class="fas fa-location-arrow"></i> Find the camera icon beside your address bar.</div>
                    <div class="help-item"><i class="fas fa-shield-halved"></i> If blocked, set permission to "Allow" then refresh.</div>
                    <div class="help-item"><i class="fas fa-sync"></i> Already allowed? Click "Allow Camera &amp; Start" again.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const localVideo = document.getElementById('local-video');
        const remotePeerVideo = document.getElementById('remote-peer');
        remotePeerVideo.muted = true; // allow autoplay without user gesture
        remotePeerVideo.playsInline = true;
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const aslOutput = document.getElementById('asl-output');
        const aslSentence = document.getElementById('asl-sentence');
        const callTimer = document.getElementById('call-timer');
        const muteBtn = document.getElementById('mute-btn');
        const videoBtn = document.getElementById('video-btn');
        const muteLabel = muteBtn.querySelector('.btn-label');
        const videoLabel = videoBtn.querySelector('.btn-label');
        const muteIcon = muteBtn.querySelector('i');
        const videoIcon = videoBtn.querySelector('i');
        const aslToggleBtn = document.getElementById('asl-toggle-btn');
        const aslToggleLabel = aslToggleBtn?.querySelector('.btn-label');
        const aslToggleIcon = aslToggleBtn?.querySelector('i');
        const endCallBtn = document.getElementById('end-call-btn');
        const logoutBtn = document.getElementById('logout-btn');
        const cameraPrompt = document.getElementById('camera-prompt');
        const startCameraBtn = document.getElementById('start-camera-btn');
        const helpToggle = document.getElementById('permissions-help');
        const helpPanel = document.getElementById('help-panel');
        const miniBars = document.querySelectorAll('.mini-bars span');
        const telemetryBars = document.querySelectorAll('.telemetry-bars span');
        const liveLetter = document.getElementById('live-letter');
        // Keep preview mirrored for the user, but send unmirrored frames so
        // backend flip matches desktop final_pred.py orientation.
        const mirrorCanvas = false;
        const ROLE = "{{ role|default('secondary') }}";
        const controlPills = document.querySelectorAll('.control-pill');
        const supportsE2EE = !!(RTCRtpSender && RTCRtpSender.prototype.createEncodedStreams);
        const statusDot = document.getElementById('call-status-dot');
        const statusText = document.getElementById('call-status-text');

        let localKeyPair = null;
        let e2eeKey = null;
        let e2eeKeyPromiseResolve = null;
        const pendingSenders = new Set();
        let remotePubJwk = null;

        let callStartTime = Date.now();
        let timerInterval;
        let isMuted = false;
        let isVideoOff = false;
        let aslEnabled = false;
        let detectLoopActive = false;
        let detectLoopTimer = null;
        let detectFailures = 0;
        const DETECT_INTERVAL_MS = 50;
        const DETECT_TIMEOUT_MS = 1800;
        const MAX_DETECT_FAILURES = 4;
        localVideo.classList.toggle('mirrored', true);
        setCallStatus('Waiting for peer...', 'connecting');

        // Button hover glow position
        controlPills.forEach(btn => {
            btn.addEventListener('mousemove', (e) => {
                const rect = btn.getBoundingClientRect();
                btn.style.setProperty('--x', `${e.clientX - rect.left}px`);
                btn.style.setProperty('--y', `${e.clientY - rect.top}px`);
            });
        });

        function flash(el) {
            if (!el) return;
            el.classList.remove('flash');
            void el.offsetWidth;
            el.classList.add('flash');
        }

        function setASLToggleState(on) {
            aslEnabled = !!on;
            if (!aslToggleBtn || !aslToggleLabel || !aslToggleIcon) return;
            aslToggleBtn.classList.toggle('active', aslEnabled);
            aslToggleBtn.classList.toggle('pill-off', !aslEnabled);
            aslToggleLabel.textContent = aslEnabled ? 'Stop ASL' : 'Start ASL';
            aslToggleIcon.className = aslEnabled ? 'fas fa-hand' : 'fas fa-hands';
        }

        // Start call timer
        function startTimer() {
            timerInterval = setInterval(() => {
                const elapsed = Date.now() - callStartTime;
                const hours = Math.floor(elapsed / 3600000);
                const minutes = Math.floor((elapsed % 3600000) / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                callTimer.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        // Initialize camera
        async function initCamera() {
            try {
                // Check if camera permission is already granted
                const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                console.log('Camera permission status:', permissionStatus.state);

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 360 },
                        frameRate: { ideal: 30, max: 30 },
                        facingMode: 'user'
                    },
                    audio: true
                });

                localVideo.srcObject = stream;
                cameraPrompt.classList.remove('visible');
                startTimer();
                startSignaling(stream);
                if (ROLE === 'primary') {
                    setASLToggleState(false);
                    aslOutput.textContent = 'Camera connected. Press Start ASL to begin interpreter.';
                    if (aslToggleBtn) aslToggleBtn.disabled = false;
                } else {
                    aslOutput.textContent = 'Viewer mode: ASL prediction off.';
                    if (aslToggleBtn) {
                        aslToggleBtn.disabled = true;
                        if (aslToggleLabel) aslToggleLabel.textContent = 'ASL Off';
                    }
                }

            } catch (error) {
                console.error('Error accessing camera:', error);

                let errorMessage = 'Camera access failed. ';
                if (error.name === 'NotAllowedError') {
                    errorMessage += 'Please click "Allow" when prompted, or enable camera in browser settings.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage += 'No camera found. Please connect a camera and refresh.';
                } else if (error.name === 'NotReadableError') {
                    errorMessage += 'Camera is already in use by another application.';
                } else {
                    errorMessage += 'Please check camera permissions and try again.';
                }

                aslOutput.textContent = errorMessage;
                cameraPrompt.classList.add('visible');
            }
        }

        // Manual camera start button
        startCameraBtn.addEventListener('click', () => {
            aslOutput.textContent = 'Requesting camera access...';
            initCamera();
        });

        if (helpToggle && helpPanel) {
            helpToggle.addEventListener('click', () => {
                const isHidden = helpPanel.hasAttribute('hidden');
                if (isHidden) {
                    helpPanel.removeAttribute('hidden');
                    helpToggle.textContent = 'Hide browser tips';
                } else {
                    helpPanel.setAttribute('hidden', '');
                    helpToggle.textContent = 'Need help unblocking?';
                }
            });
        }

        function stopASLDetection() {
            detectLoopActive = false;
            if (detectLoopTimer) {
                clearTimeout(detectLoopTimer);
                detectLoopTimer = null;
            }
            setASLToggleState(false);
        }

        // ASL Detection
        async function startASLDetection() {
            const stream = localVideo.srcObject;
            if (!stream || detectLoopActive || !aslEnabled) return;

            detectLoopActive = true;
            detectFailures = 0;

            const scheduleNext = () => {
                if (!detectLoopActive || !aslEnabled) return;
                detectLoopTimer = setTimeout(detectionTick, DETECT_INTERVAL_MS);
            };

            const detectionTick = async () => {
                if (!detectLoopActive || !aslEnabled) return;
                if (localVideo.videoWidth === 0) {
                    scheduleNext();
                    return;
                }

                try {
                    ctx.save();
                    if (mirrorCanvas) {
                        ctx.translate(canvas.width, 0);
                        ctx.scale(-1, 1);
                    }
                    ctx.drawImage(localVideo, 0, 0, canvas.width, canvas.height);
                    ctx.restore();

                    // Send raw JPEG bytes (faster than base64 JSON payloads).
                    const blob = await new Promise((resolve) => {
                        canvas.toBlob(resolve, 'image/jpeg', 0.5);
                    });
                    if (!blob) {
                        detectFailures += 1;
                        return;
                    }

                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), DETECT_TIMEOUT_MS);
                    let response;
                    try {
                        response = await fetch('/predict', {
                            method: 'POST',
                            headers: { 'Content-Type': 'image/jpeg' },
                            body: blob,
                            signal: controller.signal,
                            credentials: 'include',
                            cache: 'no-store'
                        });
                    } finally {
                        clearTimeout(timeoutId);
                    }

                    if (!response.ok) {
                        if (response.status === 401) {
                            aslOutput.textContent = 'Session expired. Please log in again to resume ASL.';
                            stopASLDetection();
                        }
                        throw new Error(`predict_failed_${response.status}`);
                    }

                    const result = await response.json();
                    detectFailures = 0;

                    if (result.letter) {
                        aslOutput.textContent = `Detected: ${result.letter}`;
                        liveLetter.textContent = result.letter;
                        flash(aslOutput);
                        flash(liveLetter);
                    }
                    if (typeof result.sentence === 'string') {
                        aslSentence.textContent = `Sentence: ${result.sentence}`;
                    }
                } catch (error) {
                    detectFailures += 1;
                    if (error.name !== 'AbortError') {
                        console.error('Error detecting ASL:', error);
                    }
                    if (detectFailures >= MAX_DETECT_FAILURES) {
                        detectFailures = 0;
                        aslOutput.textContent = 'Reconnecting ASL tracker...';
                        fetch('/reset_state', { method: 'POST' }).catch(() => {});
                    }
                } finally {
                    scheduleNext();
                }
            };

            detectionTick();
        }

        if (aslToggleBtn) {
            aslToggleBtn.disabled = true;
            aslToggleBtn.addEventListener('click', () => {
                if (ROLE !== 'primary') return;
                const stream = localVideo.srcObject;
                if (!stream) {
                    aslOutput.textContent = 'Start camera first, then press Start ASL.';
                    cameraPrompt.classList.add('visible');
                    return;
                }
                if (detectLoopActive) {
                    stopASLDetection();
                    aslOutput.textContent = 'ASL interpreter paused.';
                    liveLetter.textContent = 'Paused';
                    return;
                }
                setASLToggleState(true);
                aslOutput.textContent = 'ASL interpreter running...';
                startASLDetection();
            });
        }

        // Control buttons
        muteBtn.addEventListener('click', () => {
            const stream = localVideo.srcObject;
            if (stream) {
                const audioTrack = stream.getAudioTracks()[0];
                audioTrack.enabled = !audioTrack.enabled;
                isMuted = !isMuted;
                muteBtn.classList.toggle('active', isMuted);
                muteBtn.classList.toggle('pill-off', isMuted);
                muteLabel.textContent = isMuted ? 'Unmute' : 'Mute';
                muteIcon.className = isMuted ? 'fas fa-microphone-slash' : 'fas fa-microphone';
            }
        });

        videoBtn.addEventListener('click', () => {
            const stream = localVideo.srcObject;
            if (stream) {
                const videoTrack = stream.getVideoTracks()[0];
                videoTrack.enabled = !videoTrack.enabled;
                isVideoOff = !isVideoOff;
                videoBtn.classList.toggle('active', isVideoOff);
                videoBtn.classList.toggle('pill-off', isVideoOff);
                videoLabel.textContent = isVideoOff ? 'Turn Video On' : 'Video';
                videoIcon.className = isVideoOff ? 'fas fa-video-slash' : 'fas fa-video';
            }
        });

        endCallBtn.addEventListener('click', () => {
            stopASLDetection();
            if (localVideo.srcObject) {
                localVideo.srcObject.getTracks().forEach(track => track.stop());
            }
            clearInterval(timerInterval);
            window.location.href = '/';
        });

        logoutBtn.addEventListener('click', async () => {
            stopASLDetection();
            try {
                await fetch('/logout', { method: 'POST' });
            } catch (e) {
                console.error('Logout failed', e);
            }
            window.location.href = '/';
        });

        // Initialize on page load - show camera prompt instead of auto-starting
        window.addEventListener('load', () => {
            cameraPrompt.classList.add('visible');
            aslOutput.textContent = 'Click "Allow Camera Access" to start ASL recognition.';
        });

        // Animate tiny signal bars
        function animateBars(nodes) {
            nodes.forEach((bar, idx) => {
                const h = 20 + Math.random() * 60;
                bar.style.height = `${h}%`;
                bar.style.transition = 'height 0.28s ease';
                bar.style.transitionDelay = `${idx * 40}ms`;
            });
        }
        setInterval(() => animateBars(miniBars), 900);
        setInterval(() => animateBars(telemetryBars), 1100);

        // ------------------ WebRTC Signaling ------------------
        let pc = null;
        let remoteStream = null;

        async function startSignaling(stream) {
            if (!ROLE || (ROLE !== 'primary' && ROLE !== 'secondary')) {
                alert('Unknown role. Only primary/secondary allowed.');
                return;
            }

            const stunList = "{{ stun_urls|default('stun:stun.l.google.com:19302,stun:stun1.l.google.com:19302', true) }}"
                .split(',')
                .map(u => u.trim())
                .filter(Boolean)
                .map(urls => ({ urls }));
            const turnRaw = "{{ turn_urls|default('turn:openrelay.metered.ca:80,turn:openrelay.metered.ca:443,turn:openrelay.metered.ca:443?transport=tcp', true) }}";
            const turnUser = "{{ turn_user|default('openrelayproject', true) }}";
            const turnPass = "{{ turn_pass|default('openrelayproject', true) }}";
            const turnEntries = turnRaw.split(',').map(u => u.trim()).filter(Boolean);
            const iceServers = [...stunList];
            if (turnEntries.length) {
                iceServers.push({ urls: turnEntries, username: turnUser, credential: turnPass });
            }

            pc = new RTCPeerConnection({
                iceServers,
                iceTransportPolicy: 'all'
            });

            pc.addEventListener('connectionstatechange', () => {
                console.log('PC state', pc.connectionState);
                if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                    aslOutput.textContent = 'Connection lost. Reload to retry.';
                    try { pc.restartIce(); } catch (e) { console.warn('restartIce failed', e); }
                    setCallStatus('Reconnecting…', 'connecting');
                } else if (pc.connectionState === 'connecting') {
                    setCallStatus('Connecting…', 'connecting');
                } else if (pc.connectionState === 'connected') {
                    setCallStatus('Connected', 'connected');
                }
            });

            // Initialize E2EE (Insertable Streams)
            if (supportsE2EE) {
                setE2EEState('pending', 'E2EE pending');
                initE2EEHandshake().catch(err => {
                    console.warn('E2EE init failed', err);
                    setE2EEState('off', 'E2EE unavailable');
                });
            } else {
                console.warn('Insertable Streams not supported; skipping E2EE.');
                setE2EEState('off', 'E2EE unavailable');
            }

            // Send local tracks
            stream.getTracks().forEach(track => {
                const sender = pc.addTrack(track, stream);
                if (supportsE2EE) {
                    pendingSenders.add(sender);
                    protectSender(sender);
                }
            });

            // Remote track handler
            pc.addEventListener('track', (event) => {
                if (!remoteStream) {
                    remoteStream = new MediaStream();
                    remotePeerVideo.srcObject = remoteStream;
                }
                if (event.track) {
                    remoteStream.addTrack(event.track);
                    if (supportsE2EE) {
                        protectReceiver(event.receiver);
                    }
                    setCallStatus('Connected', 'connected');
                }
                if (remotePeerVideo.paused) {
                    remotePeerVideo.play().catch(() => {});
                }
            });

            // ICE candidate handler (HTTP signaling)
            pc.addEventListener('icecandidate', (event) => {
                if (event.candidate) {
                    sendSignal({ type: 'candidate', candidate: event.candidate });
                }
            });

            // Offer/Answer flow over HTTP polling
            if (ROLE === 'secondary') {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                sendSignal({ type: 'offer', sdp: offer });
            }
            pollSignals();
            if (ROLE === 'secondary') {
                pollDetection();
            }
        }

        // --------- E2EE Helpers (Insertable Streams) ----------
        async function initE2EEHandshake() {
            localKeyPair = await crypto.subtle.generateKey(
                { name: 'ECDH', namedCurve: 'P-256' },
                true,
                ['deriveKey']
            );
            const pubJwk = await crypto.subtle.exportKey('jwk', localKeyPair.publicKey);
            const payload = { type: 'e2ee-key', pub: pubJwk };
            if (!e2eeKeyPromiseResolve) {
                e2eeKeyPromiseResolve = () => {};
            }
            sendSignal(payload);
        }

        async function ensureSharedKey(remotePubJwk) {
            if (!supportsE2EE || !remotePubJwk || !localKeyPair) return;
            const remotePubKey = await crypto.subtle.importKey(
                'jwk',
                remotePubJwk,
                { name: 'ECDH', namedCurve: 'P-256' },
                true,
                []
            );
            e2eeKey = await crypto.subtle.deriveKey(
                { name: 'ECDH', public: remotePubKey },
                localKeyPair.privateKey,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
            if (e2eeKeyPromiseResolve) e2eeKeyPromiseResolve(e2eeKey);
            pendingSenders.forEach(protectSender);
            setE2EEState('on', 'E2EE on');
            updateFingerprint(remotePubJwk);
        }

        function getKeyPromise() {
            if (e2eeKey) return Promise.resolve(e2eeKey);
            return new Promise((resolve) => {
                e2eeKeyPromiseResolve = resolve;
            });
        }

        async function protectSender(sender) {
            if (!supportsE2EE || !sender || sender._e2eeApplied) return;
            if (!sender.createEncodedStreams) return;
            if (!e2eeKey) await getKeyPromise();
            const { readable, writable } = sender.createEncodedStreams();
            const transform = new TransformStream({
                async transform(chunk, controller) {
                    try {
                        const iv = crypto.getRandomValues(new Uint8Array(12));
                        const cipher = await crypto.subtle.encrypt(
                            { name: 'AES-GCM', iv },
                            e2eeKey,
                            chunk.data
                        );
                        const combined = new Uint8Array(iv.byteLength + cipher.byteLength);
                        combined.set(iv, 0);
                        combined.set(new Uint8Array(cipher), iv.byteLength);
                        chunk.data = combined.buffer;
                        controller.enqueue(chunk);
                    } catch (err) {
                        console.warn('Encrypt frame failed', err);
                    }
                }
            });
            readable.pipeThrough(transform).pipeTo(writable).catch(err => console.warn('Sender pipe failed', err));
            sender._e2eeApplied = true;
            pendingSenders.delete(sender);
        }

        async function protectReceiver(receiver) {
            if (!supportsE2EE || !receiver || receiver._e2eeApplied) return;
            if (!receiver.createEncodedStreams) return;
            if (!e2eeKey) await getKeyPromise();
            const { readable, writable } = receiver.createEncodedStreams();
            const transform = new TransformStream({
                async transform(chunk, controller) {
                    try {
                        const view = new Uint8Array(chunk.data);
                        const iv = view.slice(0, 12);
                        const cipher = view.slice(12);
                        const plain = await crypto.subtle.decrypt(
                            { name: 'AES-GCM', iv },
                            e2eeKey,
                            cipher
                        );
                        chunk.data = plain;
                        controller.enqueue(chunk);
                    } catch (err) {
                        console.warn('Decrypt frame failed', err);
                    }
                }
            });
            readable.pipeThrough(transform).pipeTo(writable).catch(err => console.warn('Receiver pipe failed', err));
            receiver._e2eeApplied = true;
        }

        // Secondary polls the server for latest detected letter/sentence from primary
        async function pollDetection() {
            try {
                const res = await fetch('/live_result');
                const data = await res.json();
                if (data.letter) {
                    aslOutput.textContent = `Detected: ${data.letter}`;
                }
                if (data.sentence !== undefined) {
                    aslSentence.textContent = `Sentence: ${data.sentence}`;
                }
            } catch (e) {
                console.error('pollDetection failed', e);
            } finally {
                setTimeout(pollDetection, 400);
            }
        }

        async function sendSignal(payload) {
            try {
                await fetch('/signal/send', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ role: ROLE, data: payload })
                });
            } catch (e) {
                console.error('sendSignal failed', e);
            }
        }

        async function pollSignals() {
            try {
                const res = await fetch(`/signal/recv?role=${ROLE}`);
                const { messages } = await res.json();
                for (const msg of messages) {
                    await handleSignal(msg);
                }
            } catch (e) {
                console.error('pollSignals failed', e);
            } finally {
                setTimeout(pollSignals, 500); // poll every 500ms
            }
        }

        async function handleSignal(data) {
            if (!pc) return;
            if (data.type === 'offer' && ROLE === 'primary') {
                await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                sendSignal({ type: 'answer', sdp: answer });
            } else if (data.type === 'answer' && ROLE === 'secondary') {
                await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
            } else if (data.type === 'candidate') {
                if (data.candidate) {
                    try {
                        await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                    } catch (err) {
                        console.error('addIceCandidate failed', err);
                    }
                }
            } else if (data.type === 'e2ee-key' && supportsE2EE) {
                remotePubJwk = data.pub;
                ensureSharedKey(data.pub).catch(err => console.warn('E2EE derive failed', err));
            }
        }

        function setE2EEState(state, label) {
            return; // E2EE pill removed from UI
        }

        function updateFingerprint(remoteJwk) {
            return; // fingerprint UI removed
        }

        async function computeFingerprint(localJwk, remoteJwk) {
            const concat = JSON.stringify([localJwk, remoteJwk].sort((a, b) => JSON.stringify(a).localeCompare(JSON.stringify(b))));
            const enc = new TextEncoder().encode(concat);
            const digest = await crypto.subtle.digest('SHA-256', enc);
            return [...new Uint8Array(digest)].map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function setCallStatus(label, stateClass) {
            if (statusText) statusText.textContent = label;
            if (statusDot) {
                statusDot.classList.remove('connected', 'connecting', 'disconnected');
                if (stateClass) statusDot.classList.add(stateClass);
            }
        }

        // Quick keyboard shortcuts for controls
        document.addEventListener('keydown', (e) => {
            if (e.repeat) return;
            if (e.key.toLowerCase() === 'm') document.getElementById('mute-btn')?.click();
            if (e.key.toLowerCase() === 'v') document.getElementById('video-btn')?.click();
            if (e.key.toLowerCase() === 'q') document.getElementById('end-call-btn')?.click();
        });
    </script>
</body>
</html>
